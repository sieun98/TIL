# 클로저

자신을 포함하고 있는 외부 함수보다 내부 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부 함수가 호출되었을 경우 외부 함수의 지역 변수에 접근이 가능한데 이러한 함수를 클로저라고 한다.

```js
function outer() {
  const x = 1;
  const inner = function () {
    console.log(x);
  };

  return inner;
}

const func = outer();
func(); // 출력 값: 1
```

위의 코드에서 중첩 함수 `inner`가 클로저이다.

<br/>

위의 코드처럼 어떻게 내부 함수가 외부 함수의 실행이 끝나 소멸된 이후에도 외부 함수의 변수에 접근할 수 있는 것일까? <br/>
그 이유는 클로저가 자신이 속한 렉시컬 스코프를 참조하기 때문인데, 그렇다면 <b>렉시컬 스코프</b>란 무엇일까?

<br/>

## 렉시컬 스코프

함수의 상위 스코프를 결정하는 방식에는 2가지가 있다.

1. 함수를 어디서 <b>호출</b>했는지에 따라
2. 함수를 어디서 <b>선언</b>했는지에 따라

1번 방식으로 결정하는 방식을 동적 스코프라 하고 2번 방식으로 결정하는 방식을 <b>렉시컬 스코프(정적 스코프)</b>라고 한다. <br/>
javascript 뿐만 아니라 대부분의 프로그래밍 언어에서는 렉시컬 스코프를 따른다.

※ 동적 스코프 - Bash shell, perl 등

<br/>

위의 작성된 코드에서 내부함수 `inner`가 호출되면 자신의 실행 컨텍스트가 실행 컨텍스트 스택에 쌓이고 변수 객체(Variable Object)와 스코프 체인(Scope chain) 그리고 this에 바인딩할 객체가 결정된다. 이때 스코프 체인은 전역 스코프를 가리키는 전역 객체와 함수 `outer`의 스코프를 가리키는 함수 outer의 활성 객체(Activation object) 그리고 함수 자신의 스코프를 가리키는 활성 객체를 순차적으로 바인딩한다. 스코프 체인이 바인딩한 객체가 바로 렉시컬 스코프의 실체이다.

<br/>

내부 함수 `inner`가 `outer`의 변수 x에 접근 할 수 있는 것은 렉시컬 스코프의 레퍼런스를 차레로 저장하고 있는 실행 컨텍스트의 스코프 체인을 자바스크립트 엔진이 검색했기 때문이다.

1. `inner` 함수 스코프에서 변수 x를 검색한다. → 실패!
2. `outer` 함수 스코프에서 변수 x를 검색한다. → 성공!

![Untitled](https://user-images.githubusercontent.com/88129850/181908597-6d84f6e3-e800-4132-bbd2-190023734259.png)

※ 사진 출처: https://poiemaweb.com/js-closure

이처럼 외부 함수가 이미 반환되었다 하더라도 외부 함수 내의 변수는 이를 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지되기 때문에 참조가 가능하다.

즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경인 렉시컬 스코프를 기억하여 자신이 선언되었을 때의 스코프 밖에서 호출되어도 해당 스코프에 접근할 수 있는 함수라 말할 수 있고 간단히 말해 <b>자신이 생성되었을 때의 환경을 기억하는 함수</b>이다.

❗ 내부 함수가 외부 함수의 변수에 접근할 때, 변수의 복사본이 아닌 실제 변수에 접근하는 것을 주의하자.

<br/>

## 클로저를 사용하는 이유?

### 상태 유지

클로저를 사용하면 현재 상태를 기억하고 변경된 최신 상태를 유지할 수 있다.

### 전역 변수의 사용 억제

상태 변경이나 가변 데이터를 피하고 오류를 피하는 안정성을 증가 시킬 수 있다. <br/>
❗ 전역 변수는 언제든지 누구나 접근할 수 있고 변경할 수 있어 많은 부작용을 유발해 오류의 원인이 되므로 사용을 억제해야 한다.

### 정보 은닉

클로저의 특징을 이용하여 클래스 기반 언어의 `private` 키워드를 흉내낼 수 있다.

```js
function Counter() {
  let counter = 0;

  // 클로저
  this.increase = () => ++counter;
  this.decrease = () => --counter;
}

const counter = new Counter();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2
console.log(counter.decrease()); // 1
```

생성자 함수 Counter의 변수 counter는 this에 바인딩된 프로퍼티가 아니라 변수이기 때문에 Counter의 외부에서 접근할 수가 없다.

### 모듈화에 유리

클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있고, <br/>
클로저를 통해 데이터와 메소드를 묶어다닐 수 있기에 클로저는 모듈화에 유리하다.
